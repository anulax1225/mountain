<template>
    <div x-resize="onResize($width, $height)" @click="onMouseClick" x-ref="renderView" class="relative w-full h-[100vh]">
        <mx-button @click.prevent="setPrev" class="absolute z-20 top-1/2 left-10">
            <icon-chevron-left></icon-chevron-left>
        </mx-button>
        <mx-button @click.prevent="setNext" class="absolute z-20 top-1/2 right-10">
            <icon-chevron-right></icon-chevron-right>
        </mx-button>
    </div>
</template>

<script setup>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xFFFF);
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        1500
    );
    camera.position.set(0, 0, 0.1);
    const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
        depth: true,
        powerPreference: 'high-performance'
    });
    truc();
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setSize(window.innerWidth, window.innerHeight);

    const geometry = new THREE.SphereGeometry(
        1500,        // radius
        60,         // widthSegments (higher = smoother)
        40,         // heightSegments
        0,          // phiStart
        Math.PI * 2, // phiLength
        0,          // thetaStart
        Math.PI     // thetaLength
    );

    geometry.scale(-1, 1, 1);

    const textureLoader = new THREE.TextureLoader();

    return {
        scene,
        camera,
        renderer,
        controls: null,
        currentMesh: null,
        count: 1,
        async init() {
            this.$refs.renderView.appendChild(renderer.domElement);

            await this.setPanorama(`/pano/pano${this.count}.jpeg`);

            this.controls = new OrbitControls(camera, renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.enableZoom = true;
            this.controls.enablePan = false;
            this.controls.rotateSpeed = -0.5;
            this.renderer.setAnimationLoop(this.animate.bind(this));
        },
        async setNext() {
            this.count += 1;
            await this.setPanorama(`/pano/pano${this.count}.jpeg`);
        },
        async setPrev() {
            this.count -= 1;
            await this.setPanorama(`/pano/pano${this.count}.jpeg`);
        },
        async setPanorama(panorama) {
            if(this.currentMesh) this.scene.remove(this.currentMesh);
            const texture = await textureLoader.loadAsync(panorama);
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            const material = new THREE.MeshBasicMaterial({ map: texture });
            const mesh = new THREE.Mesh(geometry, material);
            this.scene.add(mesh);
            this.currentMesh = mesh;
        },
        animate() {
            this.controls.update();
            this.renderer.render(toRaw(this.scene), toRaw(this.camera));
        },
        onResize(width, height) {
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(width, height);
        },
        async onMouseClick(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                console.log('Sphere intersection:', this.cartesianToSpherical(intersection.point));
                console.log('Hit point:', intersection.point);
                console.log('Object:', intersection.object);
                console.log('Face:', intersection.face);
                console.log('UV:', intersection.uv);

                const hotspotTexture = await textureLoader.load('/door-open.png');
                // const spriteMaterial = new THREE.SpriteMaterial({
                //     map: spriteMap,
                //     sizeAttenuation: false // Constant size regardless of distance
                // });
                const geometry = new THREE.PlaneGeometry(20, 20);
                const material = new THREE.MeshBasicMaterial({
                    map: hotspotTexture,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthTest: false
                });
                const hotspot = new THREE.Mesh(geometry, material);

                // Position it
                hotspot.position.set(intersection.point.x * 0.95, intersection.point.y * 0.95, intersection.point.z * 0.95);

                // Make it face the camera
                hotspot.lookAt(camera.position);
                hotspot.scale.set(5, 5, 0.1);
                scene.add(hotspot);

            }
        },
        cartesianToSpherical(point) {
            const radius = point.length();
            const theta = Math.atan2(point.x, point.z);
            const phi = Math.acos(point.y / radius);
            return { theta, phi, radius };
        }
    }
</script>